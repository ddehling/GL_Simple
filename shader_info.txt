# Shader Creation Guide: Depth + Alpha Blending System

## Required Imports

All shader effect files must include these imports at the top:

```python
import numpy as np
from OpenGL.GL import *
from OpenGL.GL import shaders
from typing import Dict
from .base import ShaderEffect
```

**What each import provides:**
- `numpy` - Array operations, vectorized math, efficient data handling
- `OpenGL.GL` - All OpenGL functions (glGenBuffers, glBindBuffer, etc.)
- `OpenGL.GL.shaders` - Shader compilation utilities (compileShader, compileProgram)
- `typing.Dict` - Type hints for state dictionaries
- `.base.ShaderEffect` - Base class all effects must inherit from

## Overview

The shader renderer uses **simultaneous depth testing and alpha blending** to create a proper 3D layering system where transparent objects correctly occlude each other based on depth.

## Global OpenGL State (Always Active)

Set once in create_window() - NEVER toggle in individual shaders:
- glEnable(GL_DEPTH_TEST)           # Depth testing always on
- glDepthMask(GL_TRUE)              # Allow depth writes
- glEnable(GL_BLEND)                # Alpha blending always on
- glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)  # Standard alpha blend

This means: Every fragment is depth-tested AND alpha-blended. The GPU checks "is this in front?" (depth test) then "how transparent is it?" (alpha blend).

## Depth Buffer Setup

Each viewport has:
- Color texture (RGBA) for final image
- Depth texture (GL_DEPTH_COMPONENT16) for z-ordering
- Both cleared every frame: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

## Required Shader Structure

### Vertex Shader Requirements

You MUST output proper depth values to gl_Position.z:

```glsl
#version 310 es
precision highp float;

layout(location = 0) in vec2 position;
layout(location = 1) in vec3 offset;    // x, y, z (your depth coordinate)

uniform vec2 resolution;

void main() {
    vec2 pos = position * scale + offset.xy;
    vec2 clipPos = (pos / resolution) * 2.0 - 1.0;
    clipPos.y = -clipPos.y;  // Flip Y for screen coords
    
        // CRITICAL: Map your z-coordinate where z=0 is near, z=100 is far
    float depth = offset.z / 100.0;  // Standard range: z = 0-100
    depth = clamp(depth, 0.0, 1.0);
    
    gl_Position = vec4(clipPos, depth, 1.0);
}
```

### Fragment Shader Requirements

You MUST output RGBA with meaningful alpha:

```glsl
#version 310 es
precision highp float;

out vec4 outColor;

void main() {
    vec3 color = vec3(1.0, 0.5, 0.0);
    float alpha = 0.7;
    outColor = vec4(color, alpha);
}
```

## Standard Depth Coordinate System

z = 0     ‚Üí Very near ‚Üí depth = 0.0 ‚Üí Drawn last (in front)
z = 50    ‚Üí Mid depth ‚Üí depth = 0.5 ‚Üí Middle
z = 100   ‚Üí Far away  ‚Üí depth = 1.0 ‚Üí Drawn first (behind)

Mapping formula: depth = z / 100.0 where z ‚àà [0, 100]

## How It Works

1. Rendering Order: Effects render in order added to viewport.effects
2. Fragment Processing: For each fragment:
   - GPU checks: "Is this fragment's depth closer than what's in the depth buffer?"
   - If YES: Continue to alpha blend
   - If NO: Discard fragment (it's behind something)
3. Alpha Blending: Surviving fragments blend with existing color using alpha
4. Depth Write: Opaque or semi-transparent fragments update the depth buffer

## What You Get

‚úÖ Objects at different depths correctly occlude each other
‚úÖ Transparency works naturally (alpha blending)
‚úÖ No sorting needed (GPU handles it via depth buffer)
‚úÖ Rain drops can be in front of AND behind circles depending on z-value

## Horizontal Wrapping Requirement

**All shaders MUST be continuous across the left/right boundary.**

For LED displays that wrap horizontally (like cylindrical installations), objects must appear seamless when crossing screen edges.

### Implementation:

1. **Wrap Margin**: Define a margin (e.g., 50 pixels) from each edge
2. **Detect Edge Objects**: Identify objects within wrap_margin of left or right edge
3. **Duplicate Objects**: Create temporary duplicates on the opposite side
4. **Render Both**: Draw both original and duplicate in same render call

### Example (from rain.py):

```python
self.wrap_margin = 50  # Should be larger than largest object size

# In render():
left_edge_mask = self.positions[:, 0] < self.wrap_margin
right_edge_mask = self.positions[:, 0] > (self.viewport.width - self.wrap_margin)

# Objects near left edge need duplicates on right
if np.any(left_edge_mask):
    left_indices = np.where(left_edge_mask)[0]
    duplicate_pos = self.positions[left_indices].copy()
    duplicate_pos[:, 0] += self.viewport.width  # Shift to right side
    # Add to render list

# Objects near right edge need duplicates on left
if np.any(right_edge_mask):
    right_indices = np.where(right_edge_mask)[0]
    duplicate_pos = self.positions[right_indices].copy()
    duplicate_pos[:, 0] -= self.viewport.width  # Shift to left side
    # Add to render list

# Render all: originals + duplicates in one draw call
```

### Key Points:

‚úÖ Wrap margin should exceed your largest object size
‚úÖ Duplicates share ALL attributes (color, depth, size, etc.)
‚úÖ Only X position is modified for duplicates
‚úÖ Render originals and duplicates together for efficiency
‚úÖ No gaps or pop-in at screen edges

## What NOT To Do

‚ùå Never call glEnable(GL_DEPTH_TEST) or glDisable(GL_DEPTH_TEST) in your shader
‚ùå Never call glDepthMask(GL_FALSE) unless you specifically want no depth writes
‚ùå Never omit the depth value in gl_Position.z
‚ùå Never use projection matrices that conflict with the 0-1 depth range
‚ùå Never allow objects to disappear at screen edges (breaks wrapping continuity)

## Event System Integration

**All shader effects should include an event wrapper function for use with EventScheduler.**

This allows effects to be scheduled, started, stopped, and cleaned up automatically.

### Event Wrapper Function Pattern:

```python
def shader_myeffect(state, outstate, param1=default1, param2=default2):
    """
    Shader-based effect compatible with EventScheduler
    
    Usage:
        scheduler.schedule_event(0, 60, shader_myeffect, param1=value, frame_id=0)
    
    Args:
        state: Event state dict (contains start_time, elapsed_time, count, frame_id)
        outstate: Global state dict (from EventScheduler)
        param1: Your custom parameter
        param2: Your custom parameter
    """
    # 1. Get viewport from renderer
    frame_id = state.get('frame_id', 0)
    shader_renderer = outstate.get('shader_renderer')
    
    if shader_renderer is None:
        print("WARNING: shader_renderer not found in state!")
        return
    
    viewport = shader_renderer.get_viewport(frame_id)
    if viewport is None:
        print(f"WARNING: viewport {frame_id} not found!")
        return
    
    # 2. Initialize effect on first call (count == 0)
    if state['count'] == 0:
        print(f"Initializing myeffect for frame {frame_id}")
        
        try:
            effect = viewport.add_effect(
                MyEffect,
                param1=param1,
                param2=param2
            )
            state['effect'] = effect
            print(f"‚úì Initialized shader myeffect for frame {frame_id}")
        except Exception as e:
            print(f"‚úó Failed to initialize myeffect: {e}")
            import traceback
            traceback.print_exc()
            return
    
    # 3. (Optional) Update effect from global state
    if 'effect' in state:
        state['effect'].some_param = outstate.get('some_global_param', param1)
    
    # 4. Cleanup on close event (count == -1)
    if state['count'] == -1:
        if 'effect' in state:
            print(f"Cleaning up myeffect for frame {frame_id}")
            viewport.effects.remove(state['effect'])
            state['effect'].cleanup()
            print(f"‚úì Cleaned up shader myeffect for frame {frame_id}")
```

### Event Wrapper Requirements:

‚úÖ **Function signature**: `def shader_name(state, outstate, **custom_params)`
‚úÖ **Initialize on first call**: Check `state['count'] == 0`
‚úÖ **Store effect in state**: `state['effect'] = effect` for later access
‚úÖ **Handle cleanup**: Check `state['count'] == -1` and call `cleanup()`
‚úÖ **Error handling**: Wrap initialization in try/except with traceback
‚úÖ **Logging**: Print initialization and cleanup messages
‚úÖ **Global state updates**: Optionally read from `outstate` for dynamic parameters

### Key Points:

- `state` is per-event, persists across calls
- `outstate` is global, shared across all events
- `state['count']` tracks event lifecycle: 0 (init), N>0 (running), -1 (cleanup)
- `state['elapsed_time']` provides time since event started (in seconds)
- `state['duration']` provides total event duration (if scheduled with duration)
- `frame_id` identifies which viewport to use
- Effect remains active between calls (updates/renders automatically)
- Always remove from `viewport.effects` and call `cleanup()` on close

### Fade In/Out Pattern:

For smooth transitions, implement fade in/out based on `elapsed_time`:

```python
def shader_myeffect(state, outstate, param1=1.0):
    # ... initialization code ...
    
    # Update fade factor every frame (after initialization)
    if 'effect' in state:
        elapsed_time = state['elapsed_time']
        total_duration = state.get('duration', 60)  # Default 60s if not set
        fade_duration = 10.0  # Fade in/out over 10 seconds
        
        # Calculate fade factor (0.0 to 1.0)
        if elapsed_time < fade_duration:
            # Fade in during first N seconds
            fade_factor = elapsed_time / fade_duration
        elif elapsed_time > (total_duration - fade_duration):
            # Fade out during last N seconds
            fade_factor = (total_duration - elapsed_time) / fade_duration
        else:
            # Full opacity in the middle
            fade_factor = 1.0
        
        # Update effect's fade factor (clip to 0-1 range)
        state['effect'].fade_factor = np.clip(fade_factor, 0, 1)
    
    # ... cleanup code ...
```

**In your effect class:**

```python
class MyEffect(ShaderEffect):
    def __init__(self, viewport, param1: float = 1.0):
        super().__init__(viewport)
        self.fade_factor = 0.0  # Start fully transparent
        # ... rest of init ...
    
    def render(self, state: Dict):
        glUseProgram(self.shader)
        
        # Pass fade factor to shader
        fade_loc = glGetUniformLocation(self.shader, "fadeAlpha")
        if fade_loc != -1:
            glUniform1f(fade_loc, self.fade_factor)
        
        # ... rest of render ...
```

**In your fragment shader:**

```glsl
uniform float fadeAlpha;

void main() {
    vec3 color = vec3(1.0, 0.5, 0.0);
    float alpha = 0.8;
    
    // Apply fade factor to final alpha
    alpha *= fadeAlpha;
    
    outColor = vec4(color, alpha);
}
```

**Benefits:**
- ‚úÖ Smooth fade in at start (no sudden appearance)
- ‚úÖ Smooth fade out at end (no sudden disappearance)
- ‚úÖ Automatically uses event duration from scheduler
- ‚úÖ Adjustable fade duration (independent of total duration)
- ‚úÖ Works with any effect type

## Audio Reactivity System

**Shader effects can respond to real-time audio analysis.**

The audio analyzer processes microphone input at 40 FPS, extracting 32 frequency bands from 40 Hz to 16 kHz. This data is continuously updated in `outstate['sound']` and is available to all shader effects.

### Audio Data Structure

**Access audio data in your shader wrapper function:**

```python
def shader_myeffect(state, outstate, sensitivity=1.0):
    # Get audio analysis from outstate
    audio_data = outstate.get('sound')
    
    if audio_data is None:
        return  # No audio data available yet
    
    # Audio data contains:
    # - 'raw_bands': (1000 x 32) array - Raw power in each frequency band
    # - 'norm_short': (1000 x 32) array - Normalized to short-term average (~0.25s)
    # - 'norm_long': (1000 x 32) array - Normalized to long-term average (~2.5s)
    # - 'norm_long_relu': (1000 x 32) array - ReLU(norm_long - 1), highlights above-average
    # - 'band_centers': (32,) array - Center frequency of each band (Hz)
    # - 'band_edges': (33,) array - Edge frequencies defining bands
    # - 'timestamp': float - When data was captured
    # - 'averaging_method': str - 'exponential' or 'mean'
```

### Frequency Band Mapping

The 32 frequency bands span the audible spectrum:

```python
# Bass frequencies (deep, punchy sounds)
BASS_BANDS = slice(0, 8)       # ~40-300 Hz

# Mid frequencies (vocals, guitars, most instruments)
MID_BANDS = slice(8, 20)       # ~300-2000 Hz

# High frequencies (cymbals, hi-hats, brightness)
HIGH_BANDS = slice(20, 32)     # ~2000-16000 Hz

# Sub-bass (very low rumble)
SUB_BASS_BANDS = slice(0, 4)   # ~40-150 Hz

# Upper mids (presence, clarity)
UPPER_MID_BANDS = slice(15, 25) # ~1000-5000 Hz
```

### Data Indexing

**Most recent data is at index [0]:**

```python
# Current frame (most recent)
current_bands = audio_data['raw_bands'][0]        # Shape: (32,)

# One frame ago (1/40th second = 25ms ago)
previous_frame = audio_data['raw_bands'][1]      # Shape: (32,)

# Last second of data (40 frames)
last_second = audio_data['raw_bands'][0:40]      # Shape: (40, 32)

# All available history (up to 25 seconds)
full_history = audio_data['raw_bands']            # Shape: (1000, 32)
```

### Normalization Types

**Choose the normalization that fits your effect:**

```python
# 1. RAW BANDS - Absolute power levels
#    Use for: Effects that need consistent scaling regardless of volume
raw = audio_data['raw_bands'][0]

# 2. SHORT-TERM NORMALIZED - Relative to recent average (~0.25s)
#    Use for: Beat detection, transient response, rhythmic effects
#    Value >1.0 means "louder than recent average"
short_norm = audio_data['norm_short'][0]

# 3. LONG-TERM NORMALIZED - Relative to long average (~2.5s)
#    Use for: Detecting changes in song sections, energy shifts
#    Value >1.0 means "louder than typical"
long_norm = audio_data['norm_long'][0]

# 4. LONG-TERM RELU - Only above-average energy
#    Use for: Highlighting peaks, ignoring sustained sounds
#    Value >0 means "significantly above baseline"
relu = audio_data['norm_long_relu'][0]
```

### Complete Audio-Reactive Example

```python
def shader_audio_circles(state, outstate, bass_sensitivity=1.5, mid_sensitivity=1.0):
    """
    Circles that pulse with different frequency bands
    
    Usage:
        scheduler.schedule_event(0, 60, shader_audio_circles, 
                               bass_sensitivity=2.0, frame_id=0)
    """
    frame_id = state.get('frame_id', 0)
    shader_renderer = outstate.get('shader_renderer')
    audio_data = outstate.get('sound')
    
    if shader_renderer is None:
        print("WARNING: shader_renderer not found!")
        return
    
    viewport = shader_renderer.get_viewport(frame_id)
    if viewport is None:
        print(f"WARNING: viewport {frame_id} not found!")
        return
    
    # Initialize effect
    if state['count'] == 0:
        print(f"Initializing audio_circles for frame {frame_id}")
        
        try:
            effect = viewport.add_effect(
                AudioCirclesEffect,
                bass_sensitivity=bass_sensitivity,
                mid_sensitivity=mid_sensitivity
            )
            state['effect'] = effect
            print(f"‚úì Initialized shader audio_circles")
        except Exception as e:
            print(f"‚úó Failed to initialize audio_circles: {e}")
            import traceback
            traceback.print_exc()
            return
    
    # Update effect from audio data every frame
    if 'effect' in state and audio_data is not None:
        # Get current normalized bands (use short-term for beat response)
        bands = audio_data['norm_short'][0]
        
        # Extract frequency ranges
        bass_energy = np.mean(bands[0:8])      # Bass: 40-300 Hz
        mid_energy = np.mean(bands[8:20])      # Mids: 300-2000 Hz
        high_energy = np.mean(bands[20:32])    # Highs: 2000-16000 Hz
        
        # Apply sensitivity multipliers
        state['effect'].bass_intensity = bass_energy * bass_sensitivity
        state['effect'].mid_intensity = mid_energy * mid_sensitivity
        state['effect'].high_intensity = high_energy
        
        # Optional: Detect sudden changes (beat detection)
        if len(state.get('prev_bass', [])) > 0:
            bass_delta = bass_energy - state['prev_bass']
            if bass_delta > 0.5:  # Sudden bass increase
                state['effect'].trigger_beat_flash()
        
        state['prev_bass'] = bass_energy
    
    # Cleanup
    if state['count'] == -1:
        if 'effect' in state:
            print(f"Cleaning up audio_circles")
            viewport.effects.remove(state['effect'])
            state['effect'].cleanup()
            print(f"‚úì Cleaned up shader audio_circles")


class AudioCirclesEffect(ShaderEffect):
    """Circles that respond to audio frequency bands"""
    
    def __init__(self, viewport, bass_sensitivity=1.5, mid_sensitivity=1.0):
        super().__init__(viewport)
        self.bass_sensitivity = bass_sensitivity
        self.mid_sensitivity = mid_sensitivity
        
        # Audio response parameters (updated from wrapper)
        self.bass_intensity = 0.0
        self.mid_intensity = 0.0
        self.high_intensity = 0.0
        self.beat_flash = 0.0
        
        self._initialize_circles()
    
    def _initialize_circles(self):
        """Create three circles for bass, mid, high"""
        self.num_circles = 3
        self.base_positions = np.array([
            [self.viewport.width * 0.25, self.viewport.height * 0.5, 30],  # Bass
            [self.viewport.width * 0.50, self.viewport.height * 0.5, 30],  # Mid
            [self.viewport.width * 0.75, self.viewport.height * 0.5, 30],  # High
        ], dtype=np.float32)
        
        self.base_sizes = np.array([30, 25, 20], dtype=np.float32)
        self.colors = np.array([
            [1.0, 0.2, 0.2],  # Red for bass
            [0.2, 1.0, 0.2],  # Green for mids
            [0.2, 0.2, 1.0],  # Blue for highs
        ], dtype=np.float32)
    
    def trigger_beat_flash(self):
        """Trigger a flash on beat detection"""
        self.beat_flash = 1.0
    
    def update(self, dt: float, state: Dict):
        """Update circle sizes based on audio intensity"""
        if not self.enabled:
            return
        
        # Scale circles based on audio intensity
        intensities = np.array([
            self.bass_intensity,
            self.mid_intensity,
            self.high_intensity
        ])
        
        # Clamp intensities to reasonable range (0-3x base size)
        intensities = np.clip(intensities, 0, 3)
        
        # Update circle sizes
        self.current_sizes = self.base_sizes * (1.0 + intensities)
        
        # Decay beat flash
        self.beat_flash *= 0.9
    
    def render(self, state: Dict):
        """Render audio-reactive circles"""
        if not self.enabled:
            return
        
        glUseProgram(self.shader)
        glBindVertexArray(self.VAO)
        
        # Set uniforms
        res_loc = glGetUniformLocation(self.shader, "resolution")
        glUniform2f(res_loc, self.viewport.width, self.viewport.height)
        
        beat_loc = glGetUniformLocation(self.shader, "beatFlash")
        glUniform1f(beat_loc, self.beat_flash)
        
        # Update instance data with current sizes
        instance_data = np.column_stack([
            self.base_positions,
            self.current_sizes,
            self.colors
        ]).astype(np.float32)
        
        glBindBuffer(GL_ARRAY_BUFFER, self.instance_VBO)
        glBufferSubData(GL_ARRAY_BUFFER, 0, instance_data.nbytes, instance_data)
        
        # Draw instanced circles
        glDrawElementsInstanced(GL_TRIANGLES, 6, GL_UNSIGNED_INT, None, self.num_circles)
        
        glBindVertexArray(0)
        glUseProgram(0)
    
    # ... compile_shader, get_vertex_shader, get_fragment_shader, setup_buffers ...
```

### Audio Reactivity Best Practices

‚úÖ **Use `norm_short` for beat/rhythm response** - Responds to transients and beats
‚úÖ **Use `norm_long` for gradual changes** - Smooths out fast fluctuations
‚úÖ **Use `norm_long_relu` for peak detection** - Only reacts to above-average sounds
‚úÖ **Check `audio_data is not None`** - Data may not be available immediately
‚úÖ **Apply sensitivity multipliers** - Different effects need different scaling
‚úÖ **Clamp audio values** - Prevent extreme values from breaking visuals
‚úÖ **Store previous values in `state`** - Enables beat detection and smoothing
‚úÖ **Use appropriate frequency bands** - Match your effect to relevant frequencies

### Common Audio Patterns

**Beat detection:**
```python
# Compare current to previous frame
current_bass = np.mean(audio_data['norm_short'][0][0:8])
prev_bass = np.mean(audio_data['norm_short'][1][0:8])

if current_bass > prev_bass + 0.5:  # Threshold for "beat"
    trigger_visual_effect()
```

**Smooth audio following:**
```python
# Use exponential smoothing for gradual response
if not hasattr(state['effect'], 'smoothed_energy'):
    state['effect'].smoothed_energy = 0.0

current_energy = np.mean(audio_data['norm_short'][0])
smoothing = 0.1  # 0-1, higher = faster response
state['effect'].smoothed_energy = (
    smoothing * current_energy + 
    (1 - smoothing) * state['effect'].smoothed_energy
)
```

**Frequency-specific triggers:**
```python
# Different effects for different frequencies
bass_hit = np.mean(audio_data['norm_long_relu'][0][0:8]) > 0.3
high_hit = np.mean(audio_data['norm_long_relu'][0][24:32]) > 0.2

if bass_hit:
    spawn_heavy_particle()
if high_hit:
    spawn_sparkle()
```

### Performance Considerations

- ‚úÖ Audio data is updated at 40 FPS (matches typical frame rate)
- ‚úÖ Accessing `outstate['sound']` is very fast (simple dict lookup)
- ‚úÖ NumPy operations on band data are highly optimized
- ‚ö†Ô∏è Avoid computing FFTs yourself - use provided band data
- ‚ö†Ô∏è Don't store large audio histories in effect state (use provided 1000-frame buffer)

## Shader Effect Initialization Flow

**CRITICAL: Understanding the initialization sequence**

The shader system has a specific initialization order that MUST be followed:

```
1. __init__(viewport, **params)    # Your constructor - set parameters, initialize data
2. add_effect() creates effect     # Called by viewport.add_effect(EffectClass, **params)
3. effect.init()                   # Called automatically by add_effect()
   ‚îú‚îÄ> compile_shader()            # YOU MUST IMPLEMENT THIS
   ‚îî‚îÄ> setup_buffers()             # Called after shader is compiled
```

### Key Rules:

‚úÖ **DO** initialize data structures in `__init__`
‚úÖ **DO** implement `compile_shader()` method to compile vertex/fragment shaders
‚úÖ **DO** implement `setup_buffers()` to create VAO/VBO/EBO (called after shader compiles)
‚ùå **DON'T** call `setup_buffers()` in `__init__` (shader doesn't exist yet!)
‚ùå **DON'T** call `init()` yourself (add_effect() does this automatically)
‚ùå **DON'T** try to use `self.shader` before `init()` is called

### The compile_shader() Method

Every shader effect MUST implement this method:

```python
def compile_shader(self):
    """Compile and link shaders"""
    vertex_shader = self.get_vertex_shader()
    fragment_shader = self.get_fragment_shader()
    
    try:
        vert = shaders.compileShader(vertex_shader, GL_VERTEX_SHADER)
        frag = shaders.compileShader(fragment_shader, GL_FRAGMENT_SHADER)
        shader = shaders.compileProgram(vert, frag)
        return shader
    except Exception as e:
        print(f"Shader compilation error: {e}")
        raise
```

This method is called by the base class's `init()` and must return the compiled shader program.

## Complete Shader Effect Template

Here's a complete template for creating a new shader effect:

```python
"""
My custom shader effect - description
"""
import numpy as np
from OpenGL.GL import *
from OpenGL.GL import shaders
from typing import Dict
from .base import ShaderEffect

# ============================================================================
# Event Wrapper Function - Integrates with EventScheduler
# ============================================================================

def shader_myeffect(state, outstate, param1=1.0, param2=0.0):
    """
    Shader-based effect compatible with EventScheduler
    
    Usage:
        scheduler.schedule_event(0, 60, shader_myeffect, param1=1.5, frame_id=0)
    
    Args:
        state: Event state dict
        outstate: Global state dict
        param1: Custom parameter
        param2: Custom parameter
    """
    frame_id = state.get('frame_id', 0)
    shader_renderer = outstate.get('shader_renderer')
    
    if shader_renderer is None:
        print("WARNING: shader_renderer not found in state!")
        return
    
    viewport = shader_renderer.get_viewport(frame_id)
    if viewport is None:
        print(f"WARNING: viewport {frame_id} not found!")
        return
    
    # Initialize on first call
    if state['count'] == 0:
        print(f"Initializing myeffect for frame {frame_id}")
        
        try:
            effect = viewport.add_effect(
                MyEffect,
                param1=param1,
                param2=param2
            )
            state['effect'] = effect
            print(f"‚úì Initialized shader myeffect for frame {frame_id}")
        except Exception as e:
            print(f"‚úó Failed to initialize myeffect: {e}")
            import traceback
            traceback.print_exc()
            return
    
        # Update from global state (optional)
    if 'effect' in state:
        state['effect'].param1 = outstate.get('global_param', param1)
        
        # Optional: Implement fade in/out
        elapsed_time = state['elapsed_time']
        total_duration = state.get('duration', 60)
        fade_duration = 10.0  # Adjust as needed
        
        if elapsed_time < fade_duration:
            fade_factor = elapsed_time / fade_duration
        elif elapsed_time > (total_duration - fade_duration):
            fade_factor = (total_duration - elapsed_time) / fade_duration
        else:
            fade_factor = 1.0
        
        state['effect'].fade_factor = np.clip(fade_factor, 0, 1)
    
    # Cleanup on close
    if state['count'] == -1:
        if 'effect' in state:
            print(f"Cleaning up myeffect for frame {frame_id}")
            viewport.effects.remove(state['effect'])
            state['effect'].cleanup()
            print(f"‚úì Cleaned up shader myeffect for frame {frame_id}")


# ============================================================================
# Rendering Class
# ============================================================================

class MyEffect(ShaderEffect):
    """Description of effect"""
    
        def __init__(self, viewport, param1: float = 1.0, param2: float = 0.0):
        super().__init__(viewport)
        self.param1 = param1
        self.param2 = param2
        self.instance_VBO = None
        self.fade_factor = 0.0  # For fade in/out (optional)
        
        # Initialize your data (numpy arrays, counters, etc.)
        self._initialize_data()
        
        # NOTE: Do NOT call setup_buffers() here!
        # It will be called automatically by init() after shader compilation
    
    def _initialize_data(self):
        """Initialize effect data as numpy arrays"""
        # Your initialization here (positions, colors, velocities, etc.)
        pass
    
    def compile_shader(self):
        """Compile and link shaders - REQUIRED METHOD"""
        vertex_shader = self.get_vertex_shader()
        fragment_shader = self.get_fragment_shader()
        
        try:
            vert = shaders.compileShader(vertex_shader, GL_VERTEX_SHADER)
            frag = shaders.compileShader(fragment_shader, GL_FRAGMENT_SHADER)
            shader = shaders.compileProgram(vert, frag)
            return shader
        except Exception as e:
            print(f"{self.__class__.__name__} shader compilation error: {e}")
            raise
    def get_vertex_shader(self):
        return """
        #version 310 es
        precision highp float;
        
        layout(location = 0) in vec2 position;
        layout(location = 1) in vec3 offset;  // x, y, z
        
        uniform vec2 resolution;
        
        void main() {
            vec2 pos = position + offset.xy;
            vec2 clipPos = (pos / resolution) * 2.0 - 1.0;
            clipPos.y = -clipPos.y;
            
            // Standard depth mapping
            float depth = offset.z / 100.0;
            
            gl_Position = vec4(clipPos, depth, 1.0);
        }
        """
    
    def get_fragment_shader(self):
        return """
        #version 310 es
        precision highp float;
        
        out vec4 outColor;
        
        void main() {
            // Your effect here
            outColor = vec4(1.0, 0.5, 0.0, 0.8);  // Orange, 80% opaque
        }
        """
    
        def render(self, state):
        # NO depth test toggling!
        glUseProgram(self.shader)
        # ... render your geometry ...
        glUseProgram(0)
    
        def setup_buffers(self):
        """Initialize OpenGL buffers - Called automatically after shader compilation"""
        # Create VAO
        self.VAO = glGenVertexArrays(1)
        glBindVertexArray(self.VAO)
        
        # Create VBOs and set up vertex attributes
        # Example:
        # self.position_VBO = glGenBuffers(1)
        # glBindBuffer(GL_ARRAY_BUFFER, self.position_VBO)
        # glBufferData(GL_ARRAY_BUFFER, data.nbytes, data, GL_STATIC_DRAW)
        # glEnableVertexAttribArray(0)
        # glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, ctypes.c_void_p(0))
        
        # Create EBO if using indexed rendering
        # self.EBO = glGenBuffers(1)
        # glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.EBO)
        # glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.nbytes, indices, GL_STATIC_DRAW)
        
        glBindVertexArray(0)
    
    def update(self, dt: float, state: Dict):
        """Update effect state each frame"""
        if not self.enabled:
            return
        # Your update logic here
        pass
```

## Auto-Discovery and Imports

The shader effects package uses automatic discovery. When you create a new shader file:

‚úÖ Name shader wrapper functions with `shader_` prefix: `shader_myeffect`
‚úÖ Name effect classes with `Effect` suffix: `MyEffect`
‚úÖ Both will be automatically imported by `__init__.py`
‚úÖ No need to manually edit `__init__.py`!

The auto-discovery system:
```python
# In __init__.py (already implemented):
# - Scans all .py files in shader_effects/
# - Imports functions starting with 'shader_'
# - Imports classes ending with 'Effect'
# - Makes them available globally
```

This means you just create `myeffect.py` with `shader_myeffect()` and `MyEffect` class,
and they're immediately available to the rest of the system!

## Summary

The renderer maintains global depth testing + alpha blending state. Your shader just needs to:
1. Implement `compile_shader()` method (required!)
2. Write correct depth to gl_Position.z (z=0 near/depth=0.0, z=100 far/depth=1.0)
3. Output RGBA with proper alpha in fragment shader
4. Never call `setup_buffers()` in `__init__` (init() does this after compilation)
5. Never touch depth test or blend state
6. Implement horizontal wrapping by duplicating edge objects

That's it! The system handles initialization, shader compilation, and 3D ordering automatically. üéØ

## Additional Notes

- The renderer uses OpenGL ES 3.1 for compatibility with Raspberry Pi
- All shaders must use #version 310 es and precision highp float
- Viewports have separate framebuffers for LED output at native resolution
- Window display (viewport 0 only) can be different size from framebuffer
- Effects are rendered twice: once to framebuffer (LED), once to window (if not headless)